# -*- coding: utf-8 -*-
# Generated by Django 1.11.20 on 2019-03-04 15:21
from __future__ import unicode_literals

import random
import string
from collections import defaultdict
from functools import lru_cache

from django.db import migrations
from django.utils.text import slugify
from unidecode import unidecode

# needed to keep slug creating logic at migrations because migrations work with fake models.
# This models have only ORM fields, no methods. Even "save" hook is not called.

SLUG_HASH_SIZE = 5
TAG_SLUG_MAX_LENGTH = 50
TAG_GROUP_SLUG_MAX_LENGTH = 25

APP_LABEL = 'stroyprombeton'

FIELD_TO_TAG_GROUP = {
    'specification': 'Серия',
    'length': 'Длина',
    'width': 'Ширина',
    'height': 'Высота',
    'weight': 'Масса',
    'volume': 'Объём',
    'diameter_out': 'Внешний диаметр',
    'diameter_in': 'Внутренний диаметр',
}

TAG_FIELDS = FIELD_TO_TAG_GROUP.keys()

OPTION_FIELDS = [
    'date_price_updated', 'code', 'mark', 'is_new_price', 'price', 'in_stock',
]


def randomize_slug(slug: str, hash_size: int) -> str:
    hash_size = hash_size
    slug_hash = ''.join(
        random.choices(string.ascii_lowercase, k=hash_size)
    )
    return f'{slug}_{slug_hash}'


def _get_tag_group_slug(tag_group) -> str:
    """Make a slug from the name."""
    # Translate all punctuation chars to "_".
    # It doesn't conflict with `slugify`, which translate spaces to "-"
    # and punctuation chars to "".
    slug = slugify(unidecode(tag_group.name.translate(
        {ord(p): '_' for p in string.punctuation}
    )))

    # Keep the slug length less then SLUG_MAX_LENGTH
    if len(slug) < TAG_GROUP_SLUG_MAX_LENGTH:
        return slug

    slug_length = TAG_GROUP_SLUG_MAX_LENGTH - SLUG_HASH_SIZE - 1
    return randomize_slug(
        slug[:slug_length],
        hash_size=SLUG_HASH_SIZE
    )


def _get_tag_slug(value, group) -> str:
    # Translate all punctuation chars to "_".
    # It doesn't conflict with `slugify`, which translate spaces to "-"
    # and punctuation chars to "".
    slug = slugify(unidecode(value.translate(
        {ord(p): '_' for p in string.punctuation}
    )))

    slug = '__'.join([_get_tag_group_slug(group), slug])

    # Keep the slug length less then SLUG_MAX_LENGTH
    if len(slug) < TAG_SLUG_MAX_LENGTH:
        return slug

    slug_length = TAG_SLUG_MAX_LENGTH - SLUG_HASH_SIZE - 1
    return randomize_slug(
        slug=slug[:slug_length],
        hash_size=SLUG_HASH_SIZE
    )


@lru_cache(maxsize=1)
def group_products(model) -> dict:
    grouped = defaultdict(list)
    for product in model.objects.order_by('id'):
        grouped[(product.name, product.category.id)].append(product)
    return grouped


def create_options(apps, schema_editor):
    product_model = apps.get_model(APP_LABEL, 'Product')
    option_model = apps.get_model(APP_LABEL, 'Option')

    for (name, _), products in group_products(product_model).items():
        # the product with the lowest in the groups will be only left in DB
        main_product = products[0]
        option_model.objects.bulk_create(
            [option_model(
                product=main_product,
                **{f: getattr(product, f) for f in OPTION_FIELDS},
                **{f: getattr(product, f) for f in TAG_FIELDS}
            ) for product in products]
        )


def clean_products(apps, schema_editor):
    """Safely remove product duplicates."""
    product_model = apps.get_model(APP_LABEL, 'Product')

    for (name, _), products in group_products(product_model).items():
        product_model.objects.filter(
            id__in=[p.id for p in products[1:]]
        ).delete()


def create_tags(apps, schema_editor):
    """Move data from option columns to tag records."""
    group_model = apps.get_model(APP_LABEL, 'TagGroup')
    tag_model = apps.get_model(APP_LABEL, 'Tag')
    option_model = apps.get_model(APP_LABEL, 'Option')

    field_to_group = {
        field: group_model(name=group, position=pos)
        for pos, (field, group) in enumerate(FIELD_TO_TAG_GROUP.items())
    }
    for group in field_to_group.values():
        group.save()

    for option in option_model.objects.all():
        for field, group in field_to_group.items():
            raw = getattr(option, field)
            value = str(raw).strip()
            if raw and value:
                slug = _get_tag_slug(value, group)
                tag = tag_model.objects.filter(name=value, group=group).first()
                if not tag:
                    tag = tag_model.objects.create(
                        name=value, group=group,
                        slug=slug
                    )
                # assign slug because DB we can contain tag
                # with correct value and group, but wrong slug
                tag.slug = slug
                if not tag.slug:
                    raise ValueError(f'Wrong slug for tag {tag}')
                option.tags.add(tag)
            option.save()


class Migration(migrations.Migration):

    dependencies = [
        ('stroyprombeton', '0018_index_tag_alphanumeric_name_2'),
    ]

    operations = [
        migrations.RunPython(create_options, atomic=True),
        migrations.RunPython(clean_products, atomic=True),
        migrations.RunPython(create_tags, atomic=True),
    ]
